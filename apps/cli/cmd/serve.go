package cmd

import (
	"bytes"
	"context"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"
	"time"

	"github.com/shuttl-ai/cli/ipc"
	"github.com/shuttl-ai/cli/log"
	"github.com/spf13/cobra"
	"golang.org/x/net/http2"
)

var serveCmd = &cobra.Command{
	Use:   "serve",
	Short: "Serve triggers for agents via HTTP/2",
	Long: `Serve command creates an HTTP/2 server that exposes POST endpoints
for each agent's triggers defined in the shuttl-manifest.json file.

Endpoints are created in the format: /<agent_name>/<trigger_name>

The server requires a manifest file generated by 'shuttl build'.
If no manifest file is found, an error will be thrown.

Examples:
  shuttl serve
  shuttl serve --port 8443
  shuttl serve --manifest ./custom-manifest.json
  shuttl serve --agent my-agent --trigger my-trigger --event '{"name": "my-event"}' --thread_id my-thread-id`,
	Run: runServe,
}

func init() {
	serveCmd.Flags().IntP("port", "p", 8443, "Port to serve on")
	serveCmd.Flags().StringP("manifest", "m", "shuttl-manifest.json", "Path to the manifest file")
	serveCmd.Flags().String("cert", "", "Path to TLS certificate file (optional, generates self-signed if not provided)")
	serveCmd.Flags().String("key", "", "Path to TLS private key file (optional, generates self-signed if not provided)")
	serveCmd.Flags().StringP("agent", "a", "", "Agent to serve (optional, serves all agents if not provided)")
	serveCmd.Flags().StringP("trigger", "t", "", "Trigger to serve (optional, serves all triggers if not provided)")
	serveCmd.Flags().StringP("event", "e", "", "The optional event JSON to pass to the agent and the trigger to get a response back")
	serveCmd.Flags().StringP("event_file", "f", "", "The optional event file to pass to the agent and the trigger to get a response back")
	serveCmd.Flags().StringP("thread_id", "i", "", "the thread id to use for the conversation")
	serveCmd.Flags().Bool("insecure", false, "Use HTTP/2 cleartext (h2c) without TLS (not recommended for production)")
	rootCmd.AddCommand(serveCmd)
}

// TriggerEndpoint holds information about a registered trigger endpoint
type TriggerEndpoint struct {
	Path        string `json:"path"`
	AgentName   string `json:"agentName"`
	TriggerName string `json:"triggerName"`
	TriggerType string `json:"triggerType"`
	Description string `json:"description"`
}

// triggerServer holds the server state including the IPC client
type triggerServer struct {
	client    *ipc.Client
	manifest  Manifest
	endpoints []TriggerEndpoint
}

func runServe(cmd *cobra.Command, args []string) {
	port, _ := cmd.Flags().GetInt("port")
	manifestPath, _ := cmd.Flags().GetString("manifest")
	certPath, _ := cmd.Flags().GetString("cert")
	keyPath, _ := cmd.Flags().GetString("key")
	insecure, _ := cmd.Flags().GetBool("insecure")

	agent, _ := cmd.Flags().GetString("agent")
	trigger, _ := cmd.Flags().GetString("trigger")
	event, _ := cmd.Flags().GetString("event")
	eventFile, _ := cmd.Flags().GetString("event_file")
	threadID, _ := cmd.Flags().GetString("thread_id")
	if event != "" && eventFile != "" {
		log.Error("both event and event_file cannot be provided")
		os.Exit(1)
	}

	if (event != "" || eventFile != "") && (agent == "" || trigger == "") {
		log.Error("You must provide the agent and the trigger when providing the event or event_file")
		os.Exit(1)
	}

	if trigger != "" && agent == "" {
		log.Error("you must provide the agent when providing the trigger")
		os.Exit(1)
	}

	// Check if manifest file exists
	absManifestPath, err := filepath.Abs(manifestPath)
	if err != nil {
		absManifestPath = manifestPath
	}

	if _, err := os.Stat(manifestPath); os.IsNotExist(err) {
		log.Error("manifest file not found: %s", absManifestPath)
		log.Error("Run 'shuttl build' first to generate the manifest file.")
		os.Exit(1)
	}

	// Read and parse manifest file
	manifestData, err := os.ReadFile(manifestPath)
	if err != nil {
		log.Error("Error reading manifest file: %v", err)
		os.Exit(1)
	}

	var manifest Manifest
	if err := json.Unmarshal(manifestData, &manifest); err != nil {
		log.Error("Error parsing manifest file: %v", err)
		os.Exit(1)
	}

	// Validate that the manifest has an app command
	if manifest.App == "" {
		log.Error("manifest file does not contain an 'app' command")
		log.Error("Rebuild the manifest with 'shuttl build'")
		os.Exit(1)
	}

	// Start the IPC client
	log.Info("üîß Starting app: %s", manifest.App)
	command := ipc.ParseCommand(manifest.App)
	if len(command) == 0 {
		log.Error("empty app command in manifest")
		os.Exit(1)
	}

	client := ipc.NewClient(command)
	if err := client.Start(); err != nil {
		log.Error("Error starting app: %v", err)
		os.Exit(1)
	}

	// Give the app time to initialize
	time.Sleep(500 * time.Millisecond)

	// Create the trigger server
	ts := &triggerServer{
		client:   client,
		manifest: manifest,
	}

	// Filter triggers based on agent and trigger flags
	if agent != "" {
		var filtered []ipc.TriggerInfo
		for _, t := range manifest.Triggers {
			if t.AgentName == agent {
				// If trigger is also specified, only include that specific trigger
				if trigger != "" {
					if t.Name == trigger {
						filtered = append(filtered, t)
					}
				} else {
					// Include all triggers for the agent
					filtered = append(filtered, t)
				}
			}
		}
		if len(filtered) == 0 {
			if trigger != "" {
				log.Error("trigger %s for agent %s not found in manifest", trigger, agent)
			} else {
				log.Error("no triggers found for agent %s in manifest", agent)
			}
			os.Exit(1)
		}
		manifest.Triggers = filtered
		ts.manifest.Triggers = filtered
	}

	// If event or event_file is provided, invoke the trigger directly and exit
	if event != "" || eventFile != "" {
		// Read event data
		var eventData []byte
		var err error
		if eventFile != "" {
			eventData, err = os.ReadFile(eventFile)
			if err != nil {
				log.Error("Error reading event file: %v", err)
				client.Close()
				os.Exit(1)
			}
		} else {
			eventData = []byte(event)
		}

		// Validate JSON
		if !json.Valid(eventData) {
			log.Error("event data is not valid JSON")
			client.Close()
			os.Exit(1)
		}

		// Find the trigger info
		var triggerInfo *ipc.TriggerInfo
		for _, t := range manifest.Triggers {
			if t.AgentName == agent && t.Name == trigger {
				triggerInfo = &t
				break
			}
		}
		if triggerInfo == nil {
			log.Error("trigger %s for agent %s not found", trigger, agent)
			client.Close()
			os.Exit(1)
		}

		log.Info("üöÄ Invoking trigger %s/%s...", agent, trigger)

		// Create the trigger request
		triggerReq := ipc.TriggerRequest{
			AgentName:   agent,
			TriggerName: trigger,
			TriggerType: triggerInfo.TriggerType,
			ThreadID:    threadID,
			HTTPRequest: &ipc.SerializedHTTPRequest{
				Method:      "POST",
				Path:        fmt.Sprintf("/%s/%s", agent, trigger),
				Headers:     make(map[string][]string),
				Query:       make(map[string][]string),
				Body:        json.RawMessage(eventData),
				ContentType: "application/json",
				RemoteAddr:  "cli",
				Host:        "localhost",
				Proto:       "CLI/1.0",
				Timestamp:   time.Now(),
			},
		}

		// Create context with timeout
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
		defer cancel()

		// Invoke the trigger
		response, err := client.InvokeTrigger(ctx, triggerReq)
		if err != nil {
			log.Error("Error invoking trigger: %v", err)
			client.Close()
			os.Exit(1)
		}

		// Print the result
		if response.Success {
			log.Info("‚úÖ Trigger completed successfully")
			if response.ThreadID != "" {
				log.Info("   Thread ID: %s", response.ThreadID)
			}
			if response.Result != nil {
				// Pretty print the result
				var prettyResult bytes.Buffer
				if err := json.Indent(&prettyResult, response.Result, "", "  "); err == nil {
					log.Info("   Result:\n%s", prettyResult.String())
				} else {
					log.Info("   Result: %s", string(response.Result))
				}
			}
			if len(response.Events) > 0 {
				log.Info("   Events:")
				for i, evt := range response.Events {
					var prettyEvt bytes.Buffer
					if err := json.Indent(&prettyEvt, evt, "     ", "  "); err == nil {
						log.Info("   [%d] %s", i+1, prettyEvt.String())
					} else {
						log.Info("   [%d] %s", i+1, string(evt))
					}
				}
			}
		} else {
			log.Error("Trigger failed: %s", response.Error)
			client.Close()
			os.Exit(1)
		}

		// Clean up and exit
		client.Close()
		os.Exit(0)
	}

	// Build agent-to-triggers mapping
	agentTriggers := make(map[string][]TriggerEndpoint)
	for _, trigger := range manifest.Triggers {
		endpoint := TriggerEndpoint{
			Path:        fmt.Sprintf("/%s/%s", trigger.AgentName, trigger.Name),
			AgentName:   trigger.AgentName,
			TriggerName: trigger.Name,
			TriggerType: trigger.TriggerType,
			Description: trigger.Description,
		}
		agentTriggers[trigger.AgentName] = append(agentTriggers[trigger.AgentName], endpoint)
		ts.endpoints = append(ts.endpoints, endpoint)
	}

	// Create HTTP mux and register handlers
	mux := http.NewServeMux()

	for _, triggers := range agentTriggers {
		for _, endpoint := range triggers {
			// Create a closure to capture the endpoint
			ep := endpoint
			mux.HandleFunc(ep.Path, ts.createTriggerHandler(ep))
		}
	}

	// Add a health check endpoint
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{
			"status": "ok",
			"time":   time.Now().UTC().Format(time.RFC3339),
		})
	})

	// Add a list endpoints endpoint
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path != "/" {
			http.NotFound(w, r)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"endpoints": ts.endpoints,
			"manifest": map[string]string{
				"version":   manifest.Version,
				"buildTime": manifest.BuildTime,
			},
		})
	})

	// Print startup information
	log.Info("")
	log.Info("üöÄ Shuttl Trigger Server")
	log.Info("========================")
	log.Info("üìÑ Manifest: %s", absManifestPath)
	log.Info("üì¶ Version: %s", manifest.Version)
	log.Info("üïê Built: %s", manifest.BuildTime)
	log.Info("üîå App PID: %d", client.ProcessID())
	log.Info("")

	if len(ts.endpoints) == 0 {
		log.Warn("‚ö†Ô∏è  No triggers found in manifest")
	} else {
		log.Info("üì° Registered endpoints:")
		for _, ep := range ts.endpoints {
			desc := ep.Description
			if desc == "" {
				desc = fmt.Sprintf("(%s trigger)", ep.TriggerType)
			}
			log.Info("   POST %s - %s", ep.Path, desc)
		}
	}
	log.Info("")
	log.Info("   GET  /health - Health check endpoint")
	log.Info("   GET  / - List all endpoints")
	log.Info("")

	// Create server
	server := &http.Server{
		Addr:         fmt.Sprintf(":%d", port),
		Handler:      mux,
		ReadTimeout:  30 * time.Second,
		WriteTimeout: 30 * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	// Setup graceful shutdown
	shutdownChan := make(chan os.Signal, 1)
	signal.Notify(shutdownChan, os.Interrupt, syscall.SIGTERM)

	go func() {
		<-shutdownChan
		log.Info("\n\nüõë Shutting down server...")

		// Create a context with timeout for shutdown
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()

		// Stop the HTTP server
		if err := server.Shutdown(ctx); err != nil {
			log.Error("Error shutting down HTTP server: %v", err)
		}

		// Stop the IPC client
		log.Info("   Stopping app...")
		if err := client.Close(); err != nil {
			log.Error("Error stopping app: %v", err)
		}

		log.Info("‚úÖ Server stopped")
		os.Exit(0)
	}()

	if insecure {
		// HTTP/2 cleartext (h2c) mode
		log.Warn("‚ö†Ô∏è  Starting HTTP/2 server in insecure mode (h2c)")
		log.Info("üåê Listening on http://localhost:%d", port)
		log.Info("")
		log.Info("Press Ctrl+C to stop the server")

		// Configure HTTP/2 server
		h2s := &http2.Server{}
		server.Handler = h2c(mux, h2s)

		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Error("Server error: %v", err)
			client.Close()
			os.Exit(1)
		}
	} else {
		// HTTPS mode with TLS
		var tlsConfig *tls.Config

		if certPath != "" && keyPath != "" {
			// Use provided certificates
			cert, err := tls.LoadX509KeyPair(certPath, keyPath)
			if err != nil {
				log.Error("Error loading TLS certificates: %v", err)
				client.Close()
				os.Exit(1)
			}
			tlsConfig = &tls.Config{
				Certificates: []tls.Certificate{cert},
				NextProtos:   []string{"h2", "http/1.1"},
			}
			log.Info("üîí Using provided TLS certificates")
		} else {
			// Generate self-signed certificate
			cert, err := generateSelfSignedCert()
			if err != nil {
				log.Error("Error generating self-signed certificate: %v", err)
				client.Close()
				os.Exit(1)
			}
			tlsConfig = &tls.Config{
				Certificates: []tls.Certificate{cert},
				NextProtos:   []string{"h2", "http/1.1"},
			}
			log.Info("üîí Using auto-generated self-signed TLS certificate")
		}

		server.TLSConfig = tlsConfig

		log.Info("üåê Listening on https://localhost:%d", port)
		log.Info("")
		log.Info("Press Ctrl+C to stop the server")

		// Start the server with TLS
		listener, err := tls.Listen("tcp", server.Addr, tlsConfig)
		if err != nil {
			log.Error("Error starting TLS listener: %v", err)
			client.Close()
			os.Exit(1)
		}

		if err := server.Serve(listener); err != nil && err != http.ErrServerClosed {
			log.Error("Server error: %v", err)
			client.Close()
			os.Exit(1)
		}
	}
}

// Thread ID header and query parameter names
const (
	ThreadIDHeader     = "X-Shuttl-Thread-ID"
	ThreadIDQueryParam = "thread_id"
	StreamQueryParam   = "stream"
)

// createTriggerHandler creates an HTTP handler for a trigger endpoint
func (ts *triggerServer) createTriggerHandler(endpoint TriggerEndpoint) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Only allow POST requests
		log.Info("createTriggerHandler: %s", endpoint.Path)
		if r.Method != http.MethodPost {
			w.Header().Set("Allow", "POST")
			http.Error(w, "Method not allowed. Use POST.", http.StatusMethodNotAllowed)
			return
		}

		// Read request body
		body, err := io.ReadAll(r.Body)
		if err != nil {
			http.Error(w, fmt.Sprintf("Error reading request body: %v", err), http.StatusBadRequest)
			return
		}
		defer r.Body.Close()

		// Extract thread ID from header or query parameter
		threadID := extractThreadID(r)

		// Check if streaming is requested (via query param or Accept header)
		wantsStreaming := shouldStream(r)

		// Log the trigger invocation
		streamStr := ""
		if wantsStreaming {
			streamStr = ", streaming"
		}
		if threadID != "" {
			log.Info("POST %s - Trigger invoked (thread: %s%s)", endpoint.Path, threadID, streamStr)
		} else {
			log.Info("POST %s - Trigger invoked (new thread%s)", endpoint.Path, streamStr)
		}

		// Serialize the HTTP request to JSON
		serializedReq := ts.serializeHTTPRequest(r, body)

		// Create the trigger request for IPC
		triggerReq := ipc.TriggerRequest{
			AgentName:   endpoint.AgentName,
			TriggerName: endpoint.TriggerName,
			TriggerType: endpoint.TriggerType,
			ThreadID:    threadID,
			HTTPRequest: serializedReq,
		}

		// Create a context with timeout for the IPC call
		ctx, cancel := context.WithTimeout(r.Context(), 5*time.Minute)
		defer cancel()

		if wantsStreaming {
			// Use SSE streaming
			ts.handleStreamingTrigger(w, r, ctx, endpoint, triggerReq)
		} else {
			// Use non-streaming response
			ts.handleNonStreamingTrigger(w, ctx, triggerReq)
		}
	}
}

// shouldStream checks if the client wants a streaming response
func shouldStream(r *http.Request) bool {
	// Check query parameter
	if r.URL.Query().Get(StreamQueryParam) == "true" || r.URL.Query().Get(StreamQueryParam) == "1" {
		return true
	}

	// Check Accept header for SSE
	accept := r.Header.Get("Accept")
	return strings.Contains(accept, "text/event-stream")
}

// handleNonStreamingTrigger handles a trigger request without streaming
func (ts *triggerServer) handleNonStreamingTrigger(w http.ResponseWriter, ctx context.Context, triggerReq ipc.TriggerRequest) {
	response, err := ts.client.InvokeTrigger(ctx, triggerReq)
	if err != nil {
		log.Error("   Error invoking trigger: %v", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success":   false,
			"error":     fmt.Sprintf("Failed to invoke trigger: %v", err),
			"timestamp": time.Now().UTC().Format(time.RFC3339),
		})
		return
	}

	// Return the response from the trigger
	w.Header().Set("Content-Type", "application/json")
	if response.Success {
		log.Info("   ‚úÖ Trigger completed successfully")
		w.WriteHeader(http.StatusOK)
	} else {
		log.Warn("   ‚ö†Ô∏è Trigger returned error: %s", response.Error)
		w.WriteHeader(http.StatusBadRequest)
	}
	json.NewEncoder(w).Encode(response)
}

// handleStreamingTrigger handles a trigger request with SSE streaming
func (ts *triggerServer) handleStreamingTrigger(w http.ResponseWriter, r *http.Request, ctx context.Context, endpoint TriggerEndpoint, triggerReq ipc.TriggerRequest) {
	// Check if the ResponseWriter supports flushing
	flusher, ok := w.(http.Flusher)
	if !ok {
		http.Error(w, "Streaming not supported", http.StatusInternalServerError)
		return
	}

	// Set SSE headers
	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")
	w.Header().Set("X-Accel-Buffering", "no") // Disable buffering in nginx
	w.WriteHeader(http.StatusOK)

	// Send initial connection event
	ts.sendSSEEvent(w, flusher, "connected", map[string]interface{}{
		"agent":       endpoint.AgentName,
		"trigger":     endpoint.TriggerName,
		"triggerType": endpoint.TriggerType,
		"timestamp":   time.Now().UTC().Format(time.RFC3339),
	})

	// Start streaming trigger invocation
	eventCh, errCh := ts.client.InvokeTriggerStreaming(ctx, triggerReq)

	// Process events
	for {
		select {
		case <-r.Context().Done():
			// Client disconnected
			log.Warn("   ‚ö†Ô∏è Client disconnected")
			return

		case err := <-errCh:
			if err != nil {
				log.Error("   Error in trigger stream: %v", err)
				ts.sendSSEEvent(w, flusher, "error", map[string]interface{}{
					"error":     err.Error(),
					"timestamp": time.Now().UTC().Format(time.RFC3339),
				})
			}

		case event, ok := <-eventCh:
			if !ok {
				// Channel closed, stream complete
				log.Info("   ‚úÖ Trigger stream completed")
				return
			}

			// Send the event
			eventData := map[string]interface{}{
				"type":      event.Type,
				"timestamp": time.Now().UTC().Format(time.RFC3339),
			}

			if event.Data != nil {
				eventData["data"] = json.RawMessage(event.Data)
			}
			if event.ThreadID != "" {
				eventData["threadId"] = event.ThreadID
			}
			if event.Error != "" {
				eventData["error"] = event.Error
			}
			if event.Completed {
				eventData["completed"] = true
			}

			ts.sendSSEEvent(w, flusher, event.Type, eventData)

			if event.Completed {
				log.Info("   ‚úÖ Trigger completed")
				return
			}
		}
	}
}

// sendSSEEvent sends an SSE event to the client
func (ts *triggerServer) sendSSEEvent(w http.ResponseWriter, flusher http.Flusher, eventType string, data interface{}) {
	jsonData, err := json.Marshal(data)
	if err != nil {
		log.Error("Failed to marshal SSE data: %v", err)
		return
	}

	fmt.Fprintf(w, "event: %s\n", eventType)
	fmt.Fprintf(w, "data: %s\n\n", string(jsonData))
	flusher.Flush()
}

// extractThreadID extracts the thread ID from the request header or query parameter
// Header takes precedence over query parameter
func extractThreadID(r *http.Request) string {
	// Check header first (case-insensitive)
	threadID := r.Header.Get(ThreadIDHeader)
	if threadID != "" {
		return threadID
	}

	// Also check lowercase version of the header
	threadID = r.Header.Get(strings.ToLower(ThreadIDHeader))
	if threadID != "" {
		return threadID
	}

	// Fall back to query parameter
	threadID = r.URL.Query().Get(ThreadIDQueryParam)
	return threadID
}

// serializeHTTPRequest converts an HTTP request to a serialized JSON structure
func (ts *triggerServer) serializeHTTPRequest(r *http.Request, body []byte) *ipc.SerializedHTTPRequest {
	// Convert headers to map
	headers := make(map[string][]string)
	for key, values := range r.Header {
		headers[key] = values
	}

	// Convert query parameters to map
	query := make(map[string][]string)
	for key, values := range r.URL.Query() {
		query[key] = values
	}

	// Determine content type
	contentType := r.Header.Get("Content-Type")

	// Create serialized request
	serialized := &ipc.SerializedHTTPRequest{
		Method:      r.Method,
		Path:        r.URL.Path,
		Headers:     headers,
		Query:       query,
		ContentType: contentType,
		RemoteAddr:  r.RemoteAddr,
		Host:        r.Host,
		Proto:       r.Proto,
		Timestamp:   time.Now(),
	}

	// Add body if present
	if len(body) > 0 {
		serialized.Body = json.RawMessage(body)
	}

	return serialized
}

// generateSelfSignedCert generates a self-signed TLS certificate for development
func generateSelfSignedCert() (tls.Certificate, error) {
	priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return tls.Certificate{}, fmt.Errorf("failed to generate private key: %w", err)
	}

	serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	if err != nil {
		return tls.Certificate{}, fmt.Errorf("failed to generate serial number: %w", err)
	}

	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			Organization: []string{"Shuttl AI (Development)"},
			CommonName:   "localhost",
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(24 * time.Hour), // Valid for 24 hours
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
		DNSNames:              []string{"localhost"},
	}

	certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
	if err != nil {
		return tls.Certificate{}, fmt.Errorf("failed to create certificate: %w", err)
	}

	certPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certDER})

	privBytes, err := x509.MarshalECPrivateKey(priv)
	if err != nil {
		return tls.Certificate{}, fmt.Errorf("failed to marshal private key: %w", err)
	}
	keyPEM := pem.EncodeToMemory(&pem.Block{Type: "EC PRIVATE KEY", Bytes: privBytes})

	return tls.X509KeyPair(certPEM, keyPEM)
}

// h2c wraps an http.Handler to support HTTP/2 cleartext (h2c)
func h2c(handler http.Handler, h2s *http2.Server) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Check if this is an h2c upgrade request
		if r.Method == "PRI" && r.URL.Path == "*" && r.Proto == "HTTP/2.0" {
			// This is a direct HTTP/2 connection
			conn, _, err := w.(http.Hijacker).Hijack()
			if err != nil {
				http.Error(w, "h2c hijack failed", http.StatusInternalServerError)
				return
			}
			h2s.ServeConn(conn, &http2.ServeConnOpts{
				Handler: handler,
			})
			return
		}

		// Check for HTTP/2 upgrade via Upgrade header
		if strings.Contains(r.Header.Get("Upgrade"), "h2c") {
			conn, _, err := w.(http.Hijacker).Hijack()
			if err != nil {
				http.Error(w, "h2c hijack failed", http.StatusInternalServerError)
				return
			}
			// Send upgrade response
			conn.Write([]byte("HTTP/1.1 101 Switching Protocols\r\nConnection: Upgrade\r\nUpgrade: h2c\r\n\r\n"))
			h2s.ServeConn(conn, &http2.ServeConnOpts{
				Handler: handler,
			})
			return
		}

		// Serve as regular HTTP/1.1
		handler.ServeHTTP(w, r)
	})
}
