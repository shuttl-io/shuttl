package cmd

import (
	"context"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"syscall"
	"time"

	"github.com/shuttl-ai/cli/ipc"
	"github.com/shuttl-ai/cli/log"
	"github.com/spf13/cobra"
	"golang.org/x/net/http2"
)

var serveCmd = &cobra.Command{
	Use:   "serve",
	Short: "Serve triggers for agents via HTTP/2",
	Long: `Serve command creates an HTTP/2 server that exposes POST endpoints
for each agent's triggers defined in the shuttl-manifest.json file.

Endpoints are created in the format: /<agent_name>/<trigger_name>

The server requires a manifest file generated by 'shuttl build'.
If no manifest file is found, an error will be thrown.

Examples:
  shuttl serve
  shuttl serve --port 8443
  shuttl serve --manifest ./custom-manifest.json`,
	Run: runServe,
}

func init() {
	serveCmd.Flags().IntP("port", "p", 8443, "Port to serve on")
	serveCmd.Flags().StringP("manifest", "m", "shuttl-manifest.json", "Path to the manifest file")
	serveCmd.Flags().String("cert", "", "Path to TLS certificate file (optional, generates self-signed if not provided)")
	serveCmd.Flags().String("key", "", "Path to TLS private key file (optional, generates self-signed if not provided)")
	serveCmd.Flags().Bool("insecure", false, "Use HTTP/2 cleartext (h2c) without TLS (not recommended for production)")
	rootCmd.AddCommand(serveCmd)
}

// TriggerEndpoint holds information about a registered trigger endpoint
type TriggerEndpoint struct {
	Path        string `json:"path"`
	AgentName   string `json:"agentName"`
	TriggerName string `json:"triggerName"`
	TriggerType string `json:"triggerType"`
	Description string `json:"description"`
}

// triggerServer holds the server state including the IPC client
type triggerServer struct {
	client    *ipc.Client
	manifest  Manifest
	endpoints []TriggerEndpoint
}

func runServe(cmd *cobra.Command, args []string) {
	log.Default.SetMode(log.LogToConsole)
	log.Default.SetLevel(log.LogLevelDebug)
	port, _ := cmd.Flags().GetInt("port")
	manifestPath, _ := cmd.Flags().GetString("manifest")
	certPath, _ := cmd.Flags().GetString("cert")
	keyPath, _ := cmd.Flags().GetString("key")
	insecure, _ := cmd.Flags().GetBool("insecure")

	// Check if manifest file exists
	absManifestPath, err := filepath.Abs(manifestPath)
	if err != nil {
		absManifestPath = manifestPath
	}

	if _, err := os.Stat(manifestPath); os.IsNotExist(err) {
		fmt.Fprintf(os.Stderr, "‚ùå Error: manifest file not found: %s\n", absManifestPath)
		fmt.Fprintf(os.Stderr, "   Run 'shuttl build' first to generate the manifest file.\n")
		os.Exit(1)
	}

	// Read and parse manifest file
	manifestData, err := os.ReadFile(manifestPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "‚ùå Error reading manifest file: %v\n", err)
		os.Exit(1)
	}

	var manifest Manifest
	if err := json.Unmarshal(manifestData, &manifest); err != nil {
		fmt.Fprintf(os.Stderr, "‚ùå Error parsing manifest file: %v\n", err)
		os.Exit(1)
	}

	// Validate that the manifest has an app command
	if manifest.App == "" {
		fmt.Fprintf(os.Stderr, "‚ùå Error: manifest file does not contain an 'app' command\n")
		fmt.Fprintf(os.Stderr, "   Rebuild the manifest with 'shuttl build'\n")
		os.Exit(1)
	}

	// Start the IPC client
	fmt.Printf("üîß Starting app: %s\n", manifest.App)
	command := ipc.ParseCommand(manifest.App)
	if len(command) == 0 {
		fmt.Fprintf(os.Stderr, "‚ùå Error: empty app command in manifest\n")
		os.Exit(1)
	}

	client := ipc.NewClient(command)
	if err := client.Start(); err != nil {
		fmt.Fprintf(os.Stderr, "‚ùå Error starting app: %v\n", err)
		os.Exit(1)
	}

	// Give the app time to initialize
	time.Sleep(500 * time.Millisecond)

	// Create the trigger server
	ts := &triggerServer{
		client:   client,
		manifest: manifest,
	}

	// Build agent-to-triggers mapping
	agentTriggers := make(map[string][]TriggerEndpoint)
	for _, trigger := range manifest.Triggers {
		endpoint := TriggerEndpoint{
			Path:        fmt.Sprintf("/%s/%s", trigger.AgentName, trigger.Name),
			AgentName:   trigger.AgentName,
			TriggerName: trigger.Name,
			TriggerType: trigger.TriggerType,
			Description: trigger.Description,
		}
		agentTriggers[trigger.AgentName] = append(agentTriggers[trigger.AgentName], endpoint)
		ts.endpoints = append(ts.endpoints, endpoint)
	}

	// Create HTTP mux and register handlers
	mux := http.NewServeMux()

	for _, triggers := range agentTriggers {
		for _, endpoint := range triggers {
			// Create a closure to capture the endpoint
			ep := endpoint
			mux.HandleFunc(ep.Path, ts.createTriggerHandler(ep))
		}
	}

	// Add a health check endpoint
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{
			"status": "ok",
			"time":   time.Now().UTC().Format(time.RFC3339),
		})
	})

	// Add a list endpoints endpoint
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		if r.URL.Path != "/" {
			http.NotFound(w, r)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]interface{}{
			"endpoints": ts.endpoints,
			"manifest": map[string]string{
				"version":   manifest.Version,
				"buildTime": manifest.BuildTime,
			},
		})
	})

	// Print startup information
	fmt.Println()
	fmt.Println("üöÄ Shuttl Trigger Server")
	fmt.Println("========================")
	fmt.Printf("üìÑ Manifest: %s\n", absManifestPath)
	fmt.Printf("üì¶ Version: %s\n", manifest.Version)
	fmt.Printf("üïê Built: %s\n", manifest.BuildTime)
	fmt.Printf("üîå App PID: %d\n", client.ProcessID())
	fmt.Println()

	if len(ts.endpoints) == 0 {
		fmt.Println("‚ö†Ô∏è  No triggers found in manifest")
	} else {
		fmt.Println("üì° Registered endpoints:")
		for _, ep := range ts.endpoints {
			desc := ep.Description
			if desc == "" {
				desc = fmt.Sprintf("(%s trigger)", ep.TriggerType)
			}
			fmt.Printf("   POST %s - %s\n", ep.Path, desc)
		}
	}
	fmt.Println()
	fmt.Printf("   GET  /health - Health check endpoint\n")
	fmt.Printf("   GET  / - List all endpoints\n")
	fmt.Println()

	// Create server
	server := &http.Server{
		Addr:         fmt.Sprintf(":%d", port),
		Handler:      mux,
		ReadTimeout:  30 * time.Second,
		WriteTimeout: 30 * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	// Setup graceful shutdown
	shutdownChan := make(chan os.Signal, 1)
	signal.Notify(shutdownChan, os.Interrupt, syscall.SIGTERM)

	go func() {
		<-shutdownChan
		fmt.Println("\n\nüõë Shutting down server...")

		// Create a context with timeout for shutdown
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()

		// Stop the HTTP server
		if err := server.Shutdown(ctx); err != nil {
			fmt.Fprintf(os.Stderr, "   Error shutting down HTTP server: %v\n", err)
		}

		// Stop the IPC client
		fmt.Println("   Stopping app...")
		if err := client.Close(); err != nil {
			fmt.Fprintf(os.Stderr, "   Error stopping app: %v\n", err)
		}

		fmt.Println("‚úÖ Server stopped")
		os.Exit(0)
	}()

	if insecure {
		// HTTP/2 cleartext (h2c) mode
		fmt.Printf("‚ö†Ô∏è  Starting HTTP/2 server in insecure mode (h2c)\n")
		fmt.Printf("üåê Listening on http://localhost:%d\n", port)
		fmt.Println()
		fmt.Println("Press Ctrl+C to stop the server")

		// Configure HTTP/2 server
		h2s := &http2.Server{}
		server.Handler = h2c(mux, h2s)

		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			fmt.Fprintf(os.Stderr, "‚ùå Server error: %v\n", err)
			client.Close()
			os.Exit(1)
		}
	} else {
		// HTTPS mode with TLS
		var tlsConfig *tls.Config

		if certPath != "" && keyPath != "" {
			// Use provided certificates
			cert, err := tls.LoadX509KeyPair(certPath, keyPath)
			if err != nil {
				fmt.Fprintf(os.Stderr, "‚ùå Error loading TLS certificates: %v\n", err)
				client.Close()
				os.Exit(1)
			}
			tlsConfig = &tls.Config{
				Certificates: []tls.Certificate{cert},
				NextProtos:   []string{"h2", "http/1.1"},
			}
			fmt.Printf("üîí Using provided TLS certificates\n")
		} else {
			// Generate self-signed certificate
			cert, err := generateSelfSignedCert()
			if err != nil {
				fmt.Fprintf(os.Stderr, "‚ùå Error generating self-signed certificate: %v\n", err)
				client.Close()
				os.Exit(1)
			}
			tlsConfig = &tls.Config{
				Certificates: []tls.Certificate{cert},
				NextProtos:   []string{"h2", "http/1.1"},
			}
			fmt.Printf("üîí Using auto-generated self-signed TLS certificate\n")
		}

		server.TLSConfig = tlsConfig

		fmt.Printf("üåê Listening on https://localhost:%d\n", port)
		fmt.Println()
		fmt.Println("Press Ctrl+C to stop the server")

		// Start the server with TLS
		listener, err := tls.Listen("tcp", server.Addr, tlsConfig)
		if err != nil {
			fmt.Fprintf(os.Stderr, "‚ùå Error starting TLS listener: %v\n", err)
			client.Close()
			os.Exit(1)
		}

		if err := server.Serve(listener); err != nil && err != http.ErrServerClosed {
			fmt.Fprintf(os.Stderr, "‚ùå Server error: %v\n", err)
			client.Close()
			os.Exit(1)
		}
	}
}

// Thread ID header and query parameter names
const (
	ThreadIDHeader     = "X-Shuttl-Thread-ID"
	ThreadIDQueryParam = "thread_id"
	StreamQueryParam   = "stream"
)

// createTriggerHandler creates an HTTP handler for a trigger endpoint
func (ts *triggerServer) createTriggerHandler(endpoint TriggerEndpoint) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Only allow POST requests
		log.Info("createTriggerHandler: %s", endpoint.Path)
		if r.Method != http.MethodPost {
			w.Header().Set("Allow", "POST")
			http.Error(w, "Method not allowed. Use POST.", http.StatusMethodNotAllowed)
			return
		}

		// Read request body
		body, err := io.ReadAll(r.Body)
		if err != nil {
			http.Error(w, fmt.Sprintf("Error reading request body: %v", err), http.StatusBadRequest)
			return
		}
		defer r.Body.Close()

		// Extract thread ID from header or query parameter
		threadID := extractThreadID(r)

		// Check if streaming is requested (via query param or Accept header)
		wantsStreaming := shouldStream(r)

		// Log the trigger invocation
		streamStr := ""
		if wantsStreaming {
			streamStr = ", streaming"
		}
		if threadID != "" {
			fmt.Printf("[%s] POST %s - Trigger invoked (thread: %s%s)\n", time.Now().Format("15:04:05"), endpoint.Path, threadID, streamStr)
		} else {
			fmt.Printf("[%s] POST %s - Trigger invoked (new thread%s)\n", time.Now().Format("15:04:05"), endpoint.Path, streamStr)
		}

		// Serialize the HTTP request to JSON
		serializedReq := ts.serializeHTTPRequest(r, body)

		// Create the trigger request for IPC
		triggerReq := ipc.TriggerRequest{
			AgentName:   endpoint.AgentName,
			TriggerName: endpoint.TriggerName,
			TriggerType: endpoint.TriggerType,
			ThreadID:    threadID,
			HTTPRequest: serializedReq,
		}

		// Create a context with timeout for the IPC call
		ctx, cancel := context.WithTimeout(r.Context(), 5*time.Minute)
		defer cancel()

		if wantsStreaming {
			// Use SSE streaming
			ts.handleStreamingTrigger(w, r, ctx, endpoint, triggerReq)
		} else {
			// Use non-streaming response
			ts.handleNonStreamingTrigger(w, ctx, triggerReq)
		}
	}
}

// shouldStream checks if the client wants a streaming response
func shouldStream(r *http.Request) bool {
	// Check query parameter
	if r.URL.Query().Get(StreamQueryParam) == "true" || r.URL.Query().Get(StreamQueryParam) == "1" {
		return true
	}

	// Check Accept header for SSE
	accept := r.Header.Get("Accept")
	return strings.Contains(accept, "text/event-stream")
}

// handleNonStreamingTrigger handles a trigger request without streaming
func (ts *triggerServer) handleNonStreamingTrigger(w http.ResponseWriter, ctx context.Context, triggerReq ipc.TriggerRequest) {
	response, err := ts.client.InvokeTrigger(ctx, triggerReq)
	if err != nil {
		fmt.Printf("   ‚ùå Error invoking trigger: %v\n", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success":   false,
			"error":     fmt.Sprintf("Failed to invoke trigger: %v", err),
			"timestamp": time.Now().UTC().Format(time.RFC3339),
		})
		return
	}

	// Return the response from the trigger
	w.Header().Set("Content-Type", "application/json")
	if response.Success {
		fmt.Printf("   ‚úÖ Trigger completed successfully\n")
		w.WriteHeader(http.StatusOK)
	} else {
		fmt.Printf("   ‚ö†Ô∏è Trigger returned error: %s\n", response.Error)
		w.WriteHeader(http.StatusBadRequest)
	}
	json.NewEncoder(w).Encode(response)
}

// handleStreamingTrigger handles a trigger request with SSE streaming
func (ts *triggerServer) handleStreamingTrigger(w http.ResponseWriter, r *http.Request, ctx context.Context, endpoint TriggerEndpoint, triggerReq ipc.TriggerRequest) {
	// Check if the ResponseWriter supports flushing
	flusher, ok := w.(http.Flusher)
	if !ok {
		http.Error(w, "Streaming not supported", http.StatusInternalServerError)
		return
	}

	// Set SSE headers
	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")
	w.Header().Set("X-Accel-Buffering", "no") // Disable buffering in nginx
	w.WriteHeader(http.StatusOK)

	// Send initial connection event
	ts.sendSSEEvent(w, flusher, "connected", map[string]interface{}{
		"agent":       endpoint.AgentName,
		"trigger":     endpoint.TriggerName,
		"triggerType": endpoint.TriggerType,
		"timestamp":   time.Now().UTC().Format(time.RFC3339),
	})

	// Start streaming trigger invocation
	eventCh, errCh := ts.client.InvokeTriggerStreaming(ctx, triggerReq)

	// Process events
	for {
		select {
		case <-r.Context().Done():
			// Client disconnected
			fmt.Printf("   ‚ö†Ô∏è Client disconnected\n")
			return

		case err := <-errCh:
			if err != nil {
				fmt.Printf("   ‚ùå Error in trigger stream: %v\n", err)
				ts.sendSSEEvent(w, flusher, "error", map[string]interface{}{
					"error":     err.Error(),
					"timestamp": time.Now().UTC().Format(time.RFC3339),
				})
			}

		case event, ok := <-eventCh:
			if !ok {
				// Channel closed, stream complete
				fmt.Printf("   ‚úÖ Trigger stream completed\n")
				return
			}

			// Send the event
			eventData := map[string]interface{}{
				"type":      event.Type,
				"timestamp": time.Now().UTC().Format(time.RFC3339),
			}

			if event.Data != nil {
				eventData["data"] = json.RawMessage(event.Data)
			}
			if event.ThreadID != "" {
				eventData["threadId"] = event.ThreadID
			}
			if event.Error != "" {
				eventData["error"] = event.Error
			}
			if event.Completed {
				eventData["completed"] = true
			}

			ts.sendSSEEvent(w, flusher, event.Type, eventData)

			if event.Completed {
				fmt.Printf("   ‚úÖ Trigger completed\n")
				return
			}
		}
	}
}

// sendSSEEvent sends an SSE event to the client
func (ts *triggerServer) sendSSEEvent(w http.ResponseWriter, flusher http.Flusher, eventType string, data interface{}) {
	jsonData, err := json.Marshal(data)
	if err != nil {
		log.Error("Failed to marshal SSE data: %v", err)
		return
	}

	fmt.Fprintf(w, "event: %s\n", eventType)
	fmt.Fprintf(w, "data: %s\n\n", string(jsonData))
	flusher.Flush()
}

// extractThreadID extracts the thread ID from the request header or query parameter
// Header takes precedence over query parameter
func extractThreadID(r *http.Request) string {
	// Check header first (case-insensitive)
	threadID := r.Header.Get(ThreadIDHeader)
	if threadID != "" {
		return threadID
	}

	// Also check lowercase version of the header
	threadID = r.Header.Get(strings.ToLower(ThreadIDHeader))
	if threadID != "" {
		return threadID
	}

	// Fall back to query parameter
	threadID = r.URL.Query().Get(ThreadIDQueryParam)
	return threadID
}

// serializeHTTPRequest converts an HTTP request to a serialized JSON structure
func (ts *triggerServer) serializeHTTPRequest(r *http.Request, body []byte) *ipc.SerializedHTTPRequest {
	// Convert headers to map
	headers := make(map[string][]string)
	for key, values := range r.Header {
		headers[key] = values
	}

	// Convert query parameters to map
	query := make(map[string][]string)
	for key, values := range r.URL.Query() {
		query[key] = values
	}

	// Determine content type
	contentType := r.Header.Get("Content-Type")

	// Create serialized request
	serialized := &ipc.SerializedHTTPRequest{
		Method:      r.Method,
		Path:        r.URL.Path,
		Headers:     headers,
		Query:       query,
		ContentType: contentType,
		RemoteAddr:  r.RemoteAddr,
		Host:        r.Host,
		Proto:       r.Proto,
		Timestamp:   time.Now(),
	}

	// Add body if present
	if len(body) > 0 {
		serialized.Body = json.RawMessage(body)
	}

	return serialized
}

// generateSelfSignedCert generates a self-signed TLS certificate for development
func generateSelfSignedCert() (tls.Certificate, error) {
	priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return tls.Certificate{}, fmt.Errorf("failed to generate private key: %w", err)
	}

	serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
	if err != nil {
		return tls.Certificate{}, fmt.Errorf("failed to generate serial number: %w", err)
	}

	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			Organization: []string{"Shuttl AI (Development)"},
			CommonName:   "localhost",
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(24 * time.Hour), // Valid for 24 hours
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
		DNSNames:              []string{"localhost"},
	}

	certDER, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
	if err != nil {
		return tls.Certificate{}, fmt.Errorf("failed to create certificate: %w", err)
	}

	certPEM := pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: certDER})

	privBytes, err := x509.MarshalECPrivateKey(priv)
	if err != nil {
		return tls.Certificate{}, fmt.Errorf("failed to marshal private key: %w", err)
	}
	keyPEM := pem.EncodeToMemory(&pem.Block{Type: "EC PRIVATE KEY", Bytes: privBytes})

	return tls.X509KeyPair(certPEM, keyPEM)
}

// h2c wraps an http.Handler to support HTTP/2 cleartext (h2c)
func h2c(handler http.Handler, h2s *http2.Server) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Check if this is an h2c upgrade request
		if r.Method == "PRI" && r.URL.Path == "*" && r.Proto == "HTTP/2.0" {
			// This is a direct HTTP/2 connection
			conn, _, err := w.(http.Hijacker).Hijack()
			if err != nil {
				http.Error(w, "h2c hijack failed", http.StatusInternalServerError)
				return
			}
			h2s.ServeConn(conn, &http2.ServeConnOpts{
				Handler: handler,
			})
			return
		}

		// Check for HTTP/2 upgrade via Upgrade header
		if strings.Contains(r.Header.Get("Upgrade"), "h2c") {
			conn, _, err := w.(http.Hijacker).Hijack()
			if err != nil {
				http.Error(w, "h2c hijack failed", http.StatusInternalServerError)
				return
			}
			// Send upgrade response
			conn.Write([]byte("HTTP/1.1 101 Switching Protocols\r\nConnection: Upgrade\r\nUpgrade: h2c\r\n\r\n"))
			h2s.ServeConn(conn, &http2.ServeConnOpts{
				Handler: handler,
			})
			return
		}

		// Serve as regular HTTP/1.1
		handler.ServeHTTP(w, r)
	})
}
